#include "Renderer/RendererAPI.hpp"
#include "Log/Log.hpp"
#include <GLFW/glfw3.h>
#include <algorithm>

namespace SR
{

RendererAPI::Context RendererAPI::s_context;

void RendererAPI::VulkanInitValidationLayer()
{
#ifdef SR_EDITOR
    s_context.ValidationLayers.emplace_back("VK_LAYER_KHRONOS_validation");
	s_context.EnableValidationLayers = true;
#else
	s_context.EnableValidationLayers = false;
#endif
}

bool RendererAPI::VulkanCheckValidationLayerSupport()
{
	uint32_t availableLayerCount;
	vkEnumerateInstanceLayerProperties(&availableLayerCount, NULL);

    std::vector<VkLayerProperties> availableLayers(availableLayerCount);
	vkEnumerateInstanceLayerProperties(&availableLayerCount, availableLayers.data());

	bool sucess = TRUE;
	bool layerFound;
	uint32_t j;

	for (uint32_t i = 0; i < s_context.ValidationLayers.size(); i++)
    {
		layerFound = false;

		for (j = 0; j < availableLayerCount; j++) {
			if (strcmp(s_context.ValidationLayers[i], availableLayers[j].layerName) == 0)
			{
				layerFound = true;
				break;
			}
		}

		if (!layerFound)
		{
			sucess = false;
			break;
		}
	}

	CORE_LOG_SUCCESS("   == Vulkan Validation Layers Supported ==");
	for (uint32_t i = 0; i < availableLayerCount; i++)
    {
		CORE_LOG_SUCCESS("   - NAME   %s", (const char*)availableLayers[i].layerName);
	}

	if (!sucess)
	{
		CORE_LOG_ERROR("   == Vulkan Validation Layers not found  ==");
	}

	return sucess;
}

void RendererMessageCallback::message(nvrhi::MessageSeverity severity, const char* messageText)
{
    switch (severity)
    {
    case nvrhi::MessageSeverity::Info:
    {
        CORE_LOG_DEBUG("INFO: %s", messageText);
        break;
    }
    case nvrhi::MessageSeverity::Warning:
    {
        CORE_LOG_WARNING("WARNING: %s", messageText);
        break;
    }
    case nvrhi::MessageSeverity::Error:
    {
        CORE_LOG_ERROR("ERROR: %s", messageText);
        break;
    }
    case nvrhi::MessageSeverity::Fatal:
    {
        CORE_LOG_ERROR("FATAL: %s", messageText);
        break;
    }
    }
}

void RendererAPI::Init()
{
    const char* deviceExtensions[] =
    {
        "VK_KHR_acceleration_structure",
        "VK_KHR_deferred_host_operations",
        "VK_KHR_ray_tracing_pipeline",
        // list the extensions that were requested when the device was created
    };

    VulkanInitValidationLayer();
    CreateInstance();
    s_context.PhysicalDevice = FindPhysicalDevice();
    s_context.Device = CreateDevice();
    s_context.GraphicsQueue = CreateQueue(s_context.GraphicsQueueIndex);
    //
    // nvrhi::vulkan::DeviceDesc deviceDesc;
    // deviceDesc.errorCB = &s_context.ErrorCallback;
    // deviceDesc.physicalDevice = s_context.PhysicalDevice;
    // deviceDesc.device = s_context.Device;
    // deviceDesc.graphicsQueue = s_context.GraphicsQueue;
    // deviceDesc.graphicsQueueIndex = s_context.GraphicsQueueIndex;
    // deviceDesc.deviceExtensions = deviceExtensions;
    // deviceDesc.numDeviceExtensions = std::size(deviceExtensions);
    //
    // nvrhi::DeviceHandle nvrhiDevice = nvrhi::vulkan::createDevice(deviceDesc);

    CORE_LOG_SUCCESS("NVRHI vulkan initialized");
}

void RendererAPI::Shutdown()
{
    vkDestroyDevice(s_context.Device, NULL);
    vkDestroyInstance(s_context.Instance, NULL);
}

VkPhysicalDevice RendererAPI::FindPhysicalDevice()
{
	//List all physical devices
	uint32_t deviceCount = 0;
	vkEnumeratePhysicalDevices(s_context.Instance, &deviceCount, NULL);

	CORE_ASSERT(deviceCount > 0, "Failed to find GPUs with Vulkan support!");

    std::vector<VkPhysicalDevice> devices(deviceCount);
	vkEnumeratePhysicalDevices(s_context.Instance, &deviceCount, devices.data());

	/*------------------ Search for physical device ------------------*/
	for (uint32_t i = 0; i < deviceCount; i++)
	{
		if (TryLoadingPhysicalDevice(devices[i]))
        {
			break;
		}
	}

	/*------------------ Show Total Search Results ------------------*/
	CORE_LOG_SUCCESS("   == Vulkan GPU available ==");
	for (size_t i = 0; i < deviceCount; i++)
	{
		VkPhysicalDeviceProperties properties;
		vkGetPhysicalDeviceProperties(devices[i], &properties);
		CORE_LOG_SUCCESS("   - NAME   %s", properties.deviceName);
	}

	CORE_ASSERT(s_context.PhysicalDevice != VK_NULL_HANDLE, "Failed to find a suitable GPU!");

	/*------------------ Show Selected Results ------------------*/
	CORE_LOG_SUCCESS("   == Vulkan Chosen GPU ==");
	CORE_LOG_SUCCESS("   - NAME   %s", s_context.PhysicalDeviceProperties.deviceName);

	CORE_LOG_SUCCESS("Vulkan physical device selected");
    return s_context.PhysicalDevice;
}

bool RendererAPI::TryLoadingPhysicalDevice(VkPhysicalDevice device)
{
	/*--------------------- Check For Physical Device Support ---------------------*/
	VkPhysicalDeviceProperties deviceProperties;
	vkGetPhysicalDeviceProperties(device, &deviceProperties);
	VkPhysicalDeviceFeatures deviceFeatures;
	vkGetPhysicalDeviceFeatures(device, &deviceFeatures);
	VkPhysicalDeviceMemoryProperties deviceMemoryProperties;
	vkGetPhysicalDeviceMemoryProperties(device, &deviceMemoryProperties);

	//base reuirement
	if (!deviceFeatures.samplerAnisotropy)
	{
		CORE_LOG_DEBUG("GPU [%s] does not support sampler anisotropy, skipping...", deviceProperties.deviceName);
		return FALSE;
	}

	bool supportsDeviceLocalHostVisible = FALSE;
	// check if device support local/host visible
	for (uint32_t i = 0; i < deviceMemoryProperties.memoryTypeCount; i++)
	{
		if ((deviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0 &&
			(deviceMemoryProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) != 0)
		{
			supportsDeviceLocalHostVisible = TRUE;
			break;
		}
	}

	if (supportsDeviceLocalHostVisible)
	{
		CORE_LOG_DEBUG("GPU [%s] support Local Host Visible", deviceProperties.deviceName);
	}

	/*--------------------- Cache Current GPU ---------------------*/
	s_context.PhysicalDevice = device;
	s_context.PhysicalDeviceProperties = deviceProperties;
	s_context.PhysicalDeviceFeature = deviceFeatures;
	s_context.PhysicalDeviceMemoryProperties = deviceMemoryProperties;
	s_context.SupportsDeviceLocalHostVisible = supportsDeviceLocalHostVisible;


	/*--------------------- Check For Queues Family ---------------------*/
	LoadQueueFamilies(device);
	//Bool extensionsSupported = VulkanSelectLogicalDevice(vkInfo, device);

	//Bool swapChainAdequate = FALSE;
	//FE_VulkanfeSwapChainSupportDetails swapChainSupport = VulkanSwapChainSupportByQuery(vkInfo, device);
	//swapChainAdequate = !(swapChainSupport.formats.impl.count == 0) && !(swapChainSupport.presentModes.impl.count == 0);
	//VulkanClearSwapChainSupport(&swapChainSupport);

	return s_context.GraphicsFamily && s_context.PresentFamily;//&& /*extensionsSupported && */ swapChainAdequate;
}

void RendererAPI::LoadQueueFamilies(VkPhysicalDevice device)
{
	uint32_t queueFamilyCount = 0;
	vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, NULL);

    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
	vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

	VkBool32 presentSupport = VK_FALSE;
	for (uint32_t i = 0; i < queueFamilyCount; i++)
	{
		if (queueFamilies[i].queueFlags & VK_QUEUE_GRAPHICS_BIT)
		{
			s_context.GraphicsFamily = i;
		}

		vkGetPhysicalDeviceSurfaceSupportKHR(device, i, s_context.Surface, &presentSupport);

		if (presentSupport)
        {
			s_context.PresentFamily = i;
		}

		if (queueFamilies[i].queueFlags & VK_QUEUE_GRAPHICS_BIT && presentSupport)
		{
			break;
		}
	}
}

VkDevice RendererAPI::CreateDevice()
{
    /*--------------------- Check For Device Extension Support ---------------------*/

	uint32_t extensionCount = 0;
	vkEnumerateDeviceExtensionProperties(s_context.PhysicalDevice, NULL, &extensionCount, NULL);

    std::vector<const char*> requiredDeviceExtensionsNames = { "VK_KHR_swapchain" };
    requiredDeviceExtensionsNames.reserve(6);
	if (extensionCount > 0)
	{
        std::vector<VkExtensionProperties> availableExtensions(extensionCount);
		vkEnumerateDeviceExtensionProperties(s_context.PhysicalDevice, NULL, &extensionCount, &availableExtensions[0]);

		for (uint32_t i = 0; i < extensionCount; i++)
		{
			if (strcmp(availableExtensions[i].extensionName, "VK_KHR_portability_subset") == 0)
			{
				CORE_LOG_DEBUG("Adding required device extension 'VK_KHR_portability_subset'");
				requiredDeviceExtensionsNames.emplace_back("VK_KHR_portability_subset");
			}
		}
	}

	/*--------------------- Device Feature and Dynamic rendering features ---------------------*/
	VkPhysicalDeviceFeatures2 deviceFeature = {
		.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
        .features = (VkPhysicalDeviceFeatures){
            .fillModeNonSolid = s_context.PhysicalDeviceFeature.fillModeNonSolid,
            .samplerAnisotropy = s_context.PhysicalDeviceFeature.samplerAnisotropy,
            .shaderClipDistance = s_context.PhysicalDeviceFeature.shaderClipDistance,
        }
	};

	if (!deviceFeature.features.shaderClipDistance)
	{
		CORE_LOG_ERROR("ShaderClipDistance not supported by vulkan device '%s'", s_context.PhysicalDeviceProperties.deviceName);
	}

	VkPhysicalDeviceBufferDeviceAddressFeatures deviceFeatureBufferAddress = {
		.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
		.bufferDeviceAddress = VK_TRUE,
	};

	VkPhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatures = {
		.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
        .pNext = &deviceFeatureBufferAddress,
		.dynamicRendering = VK_TRUE,
	};

	deviceFeature.pNext = &dynamicRenderingFeatures;

	requiredDeviceExtensionsNames.emplace_back(VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME);

	/*--------------------- Find Queue Families ---------------------*/

    std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;

	std::vector<uint32_t> uniqueQueueFamilies = {
        s_context.GraphicsFamily,
        s_context.PresentFamily
    };

    uniqueQueueFamilies.erase(unique(uniqueQueueFamilies.begin(), uniqueQueueFamilies.end()));

	if (uniqueQueueFamilies.size() > 1)
	{
        std::sort(uniqueQueueFamilies.begin(), uniqueQueueFamilies.end());
	}

	float queuePriority = 1.0f;

	queueCreateInfos.reserve(uniqueQueueFamilies.size());

	for (uint32_t i = 0; i < uniqueQueueFamilies.size(); i++)
	{
		VkDeviceQueueCreateInfo queueCreateInfo =
        {
			.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            .pNext = VK_NULL_HANDLE,
            .flags = 0,
			.queueFamilyIndex = uniqueQueueFamilies[i],
			.queueCount = 1,
			.pQueuePriorities = &queuePriority,
		};
		queueCreateInfos.push_back(queueCreateInfo);
	}

	/*--------------------- Fill Create infos ---------------------*/
	VkDeviceCreateInfo deviceCreateInfo = {
		.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        .pNext = &deviceFeature,
        .queueCreateInfoCount = (uint32_t)queueCreateInfos.size(),
        .pQueueCreateInfos = queueCreateInfos.data(),
		.enabledExtensionCount = (uint32_t)requiredDeviceExtensionsNames.size(),
		.ppEnabledExtensionNames = requiredDeviceExtensionsNames.data(),
	};

	if (s_context.EnableValidationLayers)
	{
		deviceCreateInfo.enabledLayerCount = (uint32_t)s_context.ValidationLayers.size();
		deviceCreateInfo.ppEnabledLayerNames = &s_context.ValidationLayers[0];
	}
	else
	{
		deviceCreateInfo.enabledLayerCount = 0;
	}

	//create device based on pyshical device and deviceCreateInfo
	VkResult result = vkCreateDevice(s_context.PhysicalDevice, &deviceCreateInfo, NULL, &s_context.Device);
	CORE_ASSERT(result == VK_SUCCESS, "failed to create logical device!");

	/*--------------------- Store Queues ---------------------*/
	vkGetDeviceQueue(s_context.Device, s_context.GraphicsFamily, 0, &s_context.GraphicsQueue);
	vkGetDeviceQueue(s_context.Device, s_context.PresentFamily, 0, &s_context.PresentQueue);

	CORE_LOG_SUCCESS("Vulkan logical device created");

    return s_context.Device;
}

static void VulkanShowDebug(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
	switch (messageSeverity)
	{
	case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:
		CORE_LOG_ERROR("Vulkan Validation layer: %s", pCallbackData->pMessage);
		return;
	case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:
		CORE_LOG_WARNING("Vulkan Validation layer: %s", pCallbackData->pMessage);
		return;
	case VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:
		CORE_LOG_DEBUG("Vulkan Validation layer: %s", pCallbackData->pMessage);
		return;
	case VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:
		CORE_LOG_DEBUG("Vulkan Validation layer: %s", pCallbackData->pMessage);
		return;
	default:
		CORE_LOG_DEBUG("Vulkan Validation layer: %s", pCallbackData->pMessage);
		return;
	}
}

static VKAPI_ATTR VkBool32 VKAPI_CALL VulkanDebugCallback(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	VkDebugUtilsMessageTypeFlagsEXT messageType,
	const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
	void* pUserData)
{
	if (RendererAPI::GetContext().EnableValidationLayers || messageSeverity >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)
	{
		VulkanShowDebug(messageSeverity, pCallbackData);
	}

	return VK_FALSE;
}

void RendererAPI::VulkanPopulateDebugMessenger(VkDebugUtilsMessengerCreateInfoEXT* createInfo)
{
	createInfo->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;

	createInfo->messageSeverity =	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
									VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
									VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
									VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;

	createInfo->messageType =	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
								VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
								VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT |
								VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT;

	createInfo->pfnUserCallback = VulkanDebugCallback;
	// createInfo->pUserData = &vkInfo->debugger;
}

void RendererAPI::CreateInstance()
{
	//Init validation layers
	if (s_context.EnableValidationLayers && !VulkanCheckValidationLayerSupport())
	{
		s_context.ValidationLayers.clear();
		CORE_LOG_ERROR("Vulkan validation layers are enabled but not available. Therefore disabling validation layers");
		s_context.EnableValidationLayers = FALSE;
	}

	//Create instance data
	VkApplicationInfo appInfo =
	{
		.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
		.pApplicationName = "Vulkan Simple Runner",
		.applicationVersion = VK_MAKE_VERSION(1, 0, 0),
		.pEngineName = "Simple Runner Engine",
		.engineVersion = VK_MAKE_VERSION(1, 0, 0),
		.apiVersion = VK_API_VERSION_1_3
	};

	VkInstanceCreateInfo createInfo =
	{
		.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
		.pApplicationInfo = &appInfo,
#ifdef FE_PLATFORM_MACOS
		.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR,
#endif
	};

	//setup validation layers/window extensions into the instance data
	VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo;
	if (s_context.EnableValidationLayers)
	{
		createInfo.enabledLayerCount = static_cast<uint32_t>(s_context.ValidationLayers.size());
		createInfo.ppEnabledLayerNames = s_context.ValidationLayers.data();
		// VulkanPopulateDebugMessenger(&debugCreateInfo);
		// createInfo.pNext = &debugCreateInfo;
	}
	else
	{
		createInfo.enabledLayerCount = 0;
		createInfo.ppEnabledLayerNames = NULL;
		createInfo.pNext = VK_NULL_HANDLE;
	}

	//window extension
    std::vector<const char*> createInfoExtensions;

#ifdef SR_PLATFORM_MACOS
	FE_ListPushValue(createInfoExtensions, const char* const, "VK_KHR_portability_enumeration");
#endif

	if (s_context.EnableValidationLayers)
    {
		createInfoExtensions.emplace_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
	}

    GLFWSetExtension(&createInfo, createInfoExtensions);

	//Get vulkan extensions
	uint32_t extensionCount;
	vkEnumerateInstanceExtensionProperties(NULL, &extensionCount, NULL);
    std::vector<VkExtensionProperties> extensions(extensionCount);

	vkEnumerateInstanceExtensionProperties(NULL, &extensionCount, extensions.data());

	CORE_LOG_SUCCESS("   == Vulkan Extensions Supported ==");

	for (uint32_t i = 0; i < extensionCount; i++)
	{
		CORE_LOG_SUCCESS("   - NAME   %s || VERSION   %d", (const char*)extensions[i].extensionName, extensions[i].specVersion);
	}

	//create instance
	VkResult result = vkCreateInstance(&createInfo, NULL, &s_context.Instance);
	CORE_ASSERT(result == VK_SUCCESS, "failed to create vulkan instance");

	CORE_LOG_SUCCESS("Vulkan instance created");
}

void RendererAPI::GLFWSetExtension(VkInstanceCreateInfo* createInfo, std::vector<const char*>&  extensions)
{
	uint32_t glfwExtensionCount = 0;
	const char* const* glfwExtensions;
	glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

    for(uint32_t i; i < glfwExtensionCount; ++i)
    {
        extensions.emplace_back(glfwExtensions[i]);
    }

	CORE_LOG_SUCCESS("   == Vulkan GLFW required extensions ==");
	for (size_t i = 0; i < extensions.size(); i++)
	{
		CORE_LOG_SUCCESS("   - NAME   %s", extensions[i]);
	}

	createInfo->enabledExtensionCount = static_cast<uint32_t>(extensions.size());
	createInfo->ppEnabledExtensionNames = extensions.data();
}

VkQueue RendererAPI::CreateQueue(int& outIndex)
{
    outIndex = 0;
    return nullptr;
}

}
